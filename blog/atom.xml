<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://prchan.com/blog</id>
    <title>PrChan's Website Blog</title>
    <updated>2023-01-05T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://prchan.com/blog"/>
    <subtitle>PrChan's Website Blog</subtitle>
    <icon>https://prchan.com/img/logo.svg</icon>
    <entry>
        <title type="html"><![CDATA[127.0.0.1 vs 0.0.0.0]]></title>
        <id>127.0.0.1 vs 0.0.0.0</id>
        <link href="https://prchan.com/blog/127.0.0.1 vs 0.0.0.0"/>
        <updated>2023-01-05T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[由一个问题引发的学习。]]></summary>
        <content type="html"><![CDATA[<p>由一个问题引发的学习。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="问题">问题<a class="hash-link" href="#问题" title="标题的直接链接">​</a></h2><p>容器中监听了 <code>0.0.0.0:&lt;port&gt;</code> 的进程和 <code>127.0.0.1:&lt;port&gt;</code> 的进程，前者可从宿主机访问到，后者则不可。为什么？</p><div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token function" style="color:#d73a49">curl</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">'127.0.0.1:&lt;port&gt;'</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># curl: (56) Recv failure: Connection reset by peer</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="问题分析">问题分析<a class="hash-link" href="#问题分析" title="标题的直接链接">​</a></h2><p>进程监听 socket，底层是调用系统函数 <code>bind(2)</code>，有 2 个参数。</p><ol><li><strong>网络接口</strong>：OS 上可能有多个网络接口，如 <code>eth0</code>。其中 <code>127.0.0.1</code> 指本机接口，<code>0.0.0.0</code> 指任意接口（类比通配符 <code>*</code>）。监听的网络接口表示只接收来自该接口的网络请求；</li><li><strong>网络端口</strong>：只接收来自该端口的网络请求。</li></ol><blockquote><p>云服务器设置安全组时，常见 <code>0.0.0.0</code>。</p></blockquote><p>在 container 中，<code>127.0.0.1</code> 特指本 container（非宿主机）。监听该网络接口则表示只接收来自本 container 的网络请求。那么，它不会接收来自本 container 外部（包括宿主机）的网络请求。但 <code>0.0.0.0</code> 则会，因为它表示接收来自任意接口的网络请求。</p><p><img loading="lazy" alt="container 网络接口的示意图" src="/assets/images/B15D04DD618F40EA9BC78272A03F3630-af36f3d4776ca7507da2f57ee903635c.png" width="944" height="902" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="解决方案">解决方案<a class="hash-link" href="#解决方案" title="标题的直接链接">​</a></h2><p>若期望到达或来自宿主机的网络请求被 container 内的进程接收，让进程监听 <code>0.0.0.0</code> 网络接口即可。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="参考">参考<a class="hash-link" href="#参考" title="标题的直接链接">​</a></h2><ol><li><a href="https://stackoverflow.com/questions/59179831/docker-app-server-ip-address-127-0-0-1-difference-of-0-0-0-0-ip" target="_blank" rel="noopener noreferrer">Docker app server ip address 127.0.0.1 difference of 0.0.0.0 ip</a></li><li><a href="https://stackoverflow.com/questions/20778771/what-is-the-difference-between-0-0-0-0-127-0-0-1-and-localhost" target="_blank" rel="noopener noreferrer">What is the difference between 0.0.0.0, 127.0.0.1 and localhost?</a></li></ol>]]></content>
        <author>
            <name>Pr Chan</name>
            <uri>https://github.com/prchann</uri>
        </author>
        <category label="network" term="network"/>
        <category label="docker" term="docker"/>
        <category label="container" term="container"/>
    </entry>
</feed>